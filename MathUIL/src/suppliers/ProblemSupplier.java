package suppliers;

import java.util.*;
import java.util.function.Supplier;
import java.util.regex.Pattern;

import base.*;
import problems.*;
import utils.EnumSetView;
import utils.refs.*;
/**
 * <p>An interface that all classes which will generate {@link Problem Problems} must implement in order for their problems
 * to be displayed to the user.</p>
 * 
 * <p>{@link ProblemSupplier ProblemSuppliers} may optionally have {@link #settings() settings}. These settings can be
 * adjusted by the user. An example of a setting would be the amount of terms in an {@link IntAddSubtract}. A
 * {@link ProblemSupplier ProblemSupplier's} settings are returned as a {@link Collection} of {@link Ref Refs}.</p>
 * 
 * <p>Every {@code ProblemSupplier} starts in {@link SupplierMode#RANDOM}.</p>
 * <p><b>Implementation note:</b> In order for a setting to be displayed to and adjusted by the user, it must be of a
 * {@link Ref} subtype that is supported by {@link SettingTitledPane#displayNodeForRef(Ref)}</p>
 * @author Sam Hooper
 */
@FunctionalInterface
public interface ProblemSupplier extends Supplier<Problem> {
			
	ObjectRef<SupplierMode> RANDOM_ONLY_REF = ObjectRef.of(SupplierMode.RANDOM);
			
	EnumSetView<SupplierMode> RANDOM_ONLY = EnumSetView.of(SupplierMode.RANDOM);
	
	static ProblemSupplier from(final String displayName, final Supplier<? extends Problem> supplier) {
		return new ProblemSupplier() {
			
			@Override
			public Problem get() {
				return supplier.get();
			}

			@Override
			public String getName() {
				return displayName;
			}
			
		};
	}
	
	/** {@link Pattern} that matches locations where a space (' ') should be placed when generating a default
	 * name from the class name of a {@code ProblemSupplier} (used in {@link #getNameFromClass(Class)}).*/
	Pattern SPACE_LOCATIONS_IN_SUPPLIER_CLASSNAME = Pattern.compile("(?<![A-Z])(?=[A-Z])|(?<!\\d)(?=\\d)");
	
	private static String getNameFromClass(Class<?> clazz) {
		final String simpleName = clazz.getSimpleName();
		final String usedPortion = simpleName.substring(0, simpleName.lastIndexOf("Supplier"));
		return SPACE_LOCATIONS_IN_SUPPLIER_CLASSNAME.matcher(usedPortion).replaceAll(" ");
	}
	
	/**
	 * Returns a {@link Problem} generated by this {@link ProblemSupplier}. The {@link Problem Problems} may be generated on-demand
	 * or in advance. {@link ProblemSupplier ProblemSuppliers} should not produce the same problem every time.
	 */
	@Override
	public Problem get();
	
	/** Returns an unmodifiable view. */
	default List<Ref> settings() {
		return Collections.emptyList();
	}
	
	default String getName() {
		return getNameFromClass(getClass());
	}
	
	/** Returns {@code true} if this {@link ProblemSupplier} supports the given {@link SupplierMode} under any {@link #settings()}.
	 * Every {@code ProblemSupplier} supports {@link SupplierMode#RANDOM}, but some may support other modes, such as {@link SupplierMode#STACKED}. */
	default boolean supportsUnderAnySettings(SupplierMode mode) {
		return getSupportedModesUnderAnySettings().contains(mode);
	}
	
	default EnumSetView<SupplierMode> getSupportedModesUnderAnySettings() {
		return RANDOM_ONLY;
	}
	
	/** Returns {@code false} for any {@link SupplierMode SupplierModes} that are not supported {@link #getSupportedModesUnderAnySettings() supported under any settings}.*/
	default boolean supportsUnderCurrentSettings(SupplierMode mode) {
		return supportsRef(mode).get();
	}
	
	/** This method is <b>not</b> required to return the same object each time it is called nor is it required to return
	 * a view of the same {@link Set} every time it is called. This implies that, if the settings change after this method
	 * is called, the returned {@code Set} may not be updated.*/
	default EnumSetView<SupplierMode> getSupportedModesUnderCurrentSettings() {
		return RANDOM_ONLY;
	}
	
	default ObjectRef<SupplierMode> getModeRef() {
		return RANDOM_ONLY_REF;
	}
	
	/** Returns the {@link SupplierMode} this {@link ProblemSupplier} was in when it produced its last {@link Problem}.*/
	default SupplierMode getLastProblemMode() {
		return SupplierMode.RANDOM;
	}
	
	default SupplierMode getMode() {
		return getModeRef().getValue();
	}
	
	/** Returns {@code true} if the mode was successfully changed and {@code false} if the given mode is the same as the current one. Throws an
	 * {@link UnsupportedOperationException} if the given mode is not {@link #supportsUnderCurrentSettings(SupplierMode) supported under the current settings}.*/
	default boolean setMode(SupplierMode newMode) {
		if(newMode == getMode())
			return false;
		throw new UnsupportedOperationException(String.format("%s is unsupported", newMode));
	}
	
	/** Called to notify this {@link ProblemSupplier} that the given {@link Problem} (generated by this {@code ProblemSupplier}) was solved correctly.*/
	default void strictlySolved(Problem p) {
		//Overridden for functionality
	}
	
	/** Called to notify this {@link ProblemSupplier} that its {@link #settings()} have changed in some way. <b>Any method
	 * that overrides this must immediately call {@code super.settingsChanged()}.</b>*/
	default void settingsChanged() {
		setMode(SupplierMode.RANDOM);
	}
	
	/** Returns an {@link MutableIntRef} containing the number of problems that have not been strictly solved in the finite set of problems being drawn from by this {@link SupplierMode#STACKED STACKED} {@link ProblemSupplier}.
	 * Behavior undefined if this {@code ProblemSupplier} is not currently in {@code STACKED} mode (may return {@code null}, throw an exception, return an {@code IntRef}, etc.).*/
	default IntRef getStackedUnsolved() {
		throw new UnsupportedOperationException("This ProblemSupplier is not in stacked mode.");
	}
	
	/** Returns a {@link BooleanRef} whose {@link BooleanRef #get() value} is whether or not this {@link ProblemSupplier} supports
	 * the given {@link SupplierMode} under its current {@link #settings() settings}. This method always returns the same object when
	 * given the same {@code SupplierMode}.*/
	default BooleanRef supportsRef(SupplierMode mode) {
		return BooleanRef.of(mode == SupplierMode.RANDOM);
	}
	
}
